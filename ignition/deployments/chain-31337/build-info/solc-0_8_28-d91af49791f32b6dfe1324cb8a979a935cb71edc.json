{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-d91af49791f32b6dfe1324cb8a979a935cb71edc",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/AcademicRecordStorage.sol": "project/contracts/AcademicRecordStorage.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/AcademicRecordStorage.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract AcademicRecordStorage {\n    event InstitutionAdded(address indexed institutionAddress, string name);\n    event CourseAdded(address indexed institutionAddress, string courseCode);\n    event DisciplineAdded(string courseCode, string disciplineCode);\n    event StudentAdded(address indexed studentAddress);\n    event GradeAdded(\n        address indexed studentAddress,\n        string disciplineCode,\n        uint16 year,\n        uint8 semester\n    );\n    event AllowedAddressAdded(\n        address indexed studentAddress,\n        address allowedAddress\n    );\n    event StudentInformationAdded(address indexed studentAddress);\n\n    address public immutable contractOwner;\n    address[] private institutionAddressList;\n    mapping(address => bool) public isInstitution;\n\n    struct Institution {\n        address institutionAddress;\n        string name;\n        string document;\n        string publicKey;\n    }\n\n    struct Course {\n        string code;\n        string name;\n        string courseType;\n        int numberOfSemesters;\n    }\n\n    struct Discipline {\n        string code;\n        string name;\n        string syllabus;\n        int workload;\n        int creditCount;\n    }\n\n    struct Student {\n        address studentAddress;\n        string selfEncryptedInformation;\n        string institutionEncryptedInformation;\n        string publicKey;\n        string publicHash;\n    }\n\n    struct Grade {\n        string disciplineCode;\n        uint8 semester;\n        uint16 year;\n        uint8 grade;\n        uint8 attendance;\n        bool status;\n    }\n\n    struct BatchGradePayload {\n        address studentAddress;\n        string courseCode;\n        string disciplineCode;\n        uint8 semester;\n        uint16 year;\n        uint8 grade;\n        uint8 attendance;\n        bool status;\n    }\n\n    mapping(address => Institution) private institutions;\n    mapping(address => Course[]) private courses;\n    mapping(address => Student) private students;\n    mapping(address => Grade[]) private grades;\n    mapping(bytes32 => mapping(bytes32 => bool))\n        private disciplineExistsInCourse;\n    mapping(bytes32 => Discipline[]) private disciplinesByCourse;\n    mapping(address => mapping(bytes32 => bool)) private enrollments;\n    mapping(address => mapping(address => string)) private recipientEncryptKey;\n    mapping(address => mapping(address => string)) private studentInfoRecipient;\n    mapping(address => address) private studentToInstitution;\n    mapping(address => string) private studentToCourse;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == contractOwner,\n            \"Only the contract owner can perform this action!\"\n        );\n        _;\n    }\n\n    modifier onlyInstitution() {\n        require(\n            isInstitution[msg.sender],\n            \"Caller is not a registered institution!\"\n        );\n        _;\n    }\n\n    modifier onlyStudent(address studentAddress) {\n        require(\n            msg.sender == studentAddress,\n            \"Only the student can perform this action!\"\n        );\n        _;\n    }\n\n    modifier institutionExists(address institutionAddress) {\n        require(\n            institutions[institutionAddress].institutionAddress != address(0),\n            \"Institution is not registered!\"\n        );\n        _;\n    }\n\n    modifier studentExists(address studentAddress) {\n        require(\n            students[studentAddress].studentAddress != address(0),\n            \"Student is not registered!\"\n        );\n        _;\n    }\n\n    modifier studentIsInstitution(\n        address studentAddress,\n        address institutionAddress\n    ) {\n        require(\n            studentToInstitution[studentAddress] == institutionAddress,\n            \"Student is not in this Institution!\"\n        );\n        _;\n    }\n\n    modifier courseExists(\n        address _institutionAddress,\n        string memory _courseCode\n    ) {\n        bool exists = false;\n        Course[] storage institutionCourses = courses[_institutionAddress];\n        for (uint256 i = 0; i < institutionCourses.length; i++) {\n            if (\n                keccak256(abi.encodePacked(institutionCourses[i].code)) ==\n                keccak256(abi.encodePacked(_courseCode))\n            ) {\n                exists = true;\n                break;\n            }\n        }\n        require(exists, \"Course not found!\");\n        _;\n    }\n\n    modifier disciplineExists(bytes32 _courseHash, bytes32 _disciplineHash) {\n        require(\n            disciplineExistsInCourse[_courseHash][_disciplineHash],\n            \"Discipline not found in this course!\"\n        );\n        _;\n    }\n\n    constructor() {\n        contractOwner = msg.sender;\n    }\n\n    function owner() public view returns (address) {\n        return contractOwner;\n    }\n\n    function addInstitution(\n        address _institutionAddress,\n        string calldata _name,\n        string calldata _document\n    ) public onlyOwner {\n        require(\n            institutions[_institutionAddress].institutionAddress == address(0),\n            \"Institution already registered!\"\n        );\n        institutions[_institutionAddress] = Institution(\n            _institutionAddress,\n            _name,\n            _document,\n            \"\"\n        );\n        institutionAddressList.push(_institutionAddress);\n        isInstitution[_institutionAddress] = true;\n        emit InstitutionAdded(_institutionAddress, _name);\n    }\n\n    function addInstitutionPublicKey(\n        address _institutionAddress,\n        string calldata _publicKey\n    ) public onlyInstitution {\n        require(\n            msg.sender == _institutionAddress,\n            \"Only the institution itself can add its public key!\"\n        );\n        institutions[_institutionAddress].publicKey = _publicKey;\n    }\n\n    function getInstitution(\n        address _institutionAddress\n    ) public view returns (Institution memory) {\n        return institutions[_institutionAddress];\n    }\n\n    function getInstitutionList() public view returns (address[] memory) {\n        return institutionAddressList;\n    }\n\n    function addCourse(\n        address _institutionAddress,\n        string calldata _code,\n        string calldata _name,\n        string calldata _courseType,\n        int _numberOfSemesters\n    ) public institutionExists(_institutionAddress) onlyInstitution {\n        require(\n            msg.sender == _institutionAddress,\n            \"Only the specified institution can add courses to itself.\"\n        );\n        Course[] storage institutionCourses = courses[_institutionAddress];\n        for (uint256 i = 0; i < institutionCourses.length; i++) {\n            require(\n                keccak256(abi.encodePacked(institutionCourses[i].code)) !=\n                    keccak256(abi.encodePacked(_code)),\n                \"Course already registered!\"\n            );\n        }\n        courses[_institutionAddress].push(\n            Course(_code, _name, _courseType, _numberOfSemesters)\n        );\n        emit CourseAdded(_institutionAddress, _code);\n    }\n\n    function addDisciplineToCourse(\n        address institutionAddress,\n        string calldata courseCode,\n        string calldata disciplineCode,\n        string calldata name,\n        string calldata syllabus,\n        int workload,\n        int creditCount\n    ) public courseExists(institutionAddress, courseCode) onlyInstitution {\n        _addDisciplineToCourse(\n            courseCode,\n            disciplineCode,\n            name,\n            syllabus,\n            workload,\n            creditCount\n        );\n    }\n\n    function _addDisciplineToCourse(\n        string calldata courseCode,\n        string calldata disciplineCode,\n        string calldata name,\n        string calldata syllabus,\n        int workload,\n        int creditCount\n    ) internal {\n        bytes32 courseHash = keccak256(abi.encodePacked(courseCode));\n        bytes32 disciplineHash = keccak256(abi.encodePacked(disciplineCode));\n\n        require(\n            !disciplineExistsInCourse[courseHash][disciplineHash],\n            \"Discipline already registered in this course!\"\n        );\n\n        disciplinesByCourse[courseHash].push(\n            Discipline(disciplineCode, name, syllabus, workload, creditCount)\n        );\n        disciplineExistsInCourse[courseHash][disciplineHash] = true;\n\n        emit DisciplineAdded(courseCode, disciplineCode);\n    }\n\n    function addStudent(\n        address _institutionAddress,\n        address _studentAddress\n    ) public institutionExists(_institutionAddress) onlyInstitution {\n        require(\n            msg.sender == _institutionAddress,\n            \"Only the specified institution can add students to itself.\"\n        );\n        require(\n            students[_studentAddress].studentAddress == address(0),\n            \"Student already registered!\"\n        );\n        students[_studentAddress] = Student(_studentAddress, \"\", \"\", \"\", \"\");\n        studentToInstitution[_studentAddress] = _institutionAddress;\n        emit StudentAdded(_studentAddress);\n    }\n\n    function getStudent(\n        address _studentAddress\n    ) public view returns (Student memory) {\n        return students[_studentAddress];\n    }\n\n    function addGrade(\n        address _institutionAddress,\n        address _studentAddress,\n        string calldata _courseCode,\n        Grade calldata _gradeInfo\n    )\n        public\n        institutionExists(_institutionAddress)\n        onlyInstitution\n        studentExists(_studentAddress)\n    {\n        require(\n            msg.sender == _institutionAddress,\n            \"Only the specified institution can add grades.\"\n        );\n        bytes32 courseHash = keccak256(abi.encodePacked(_courseCode));\n        bytes32 disciplineHash = keccak256(\n            abi.encodePacked(_gradeInfo.disciplineCode)\n        );\n\n        require(\n            disciplineExistsInCourse[courseHash][disciplineHash],\n            \"Discipline not found in this course!\"\n        );\n        if (bytes(studentToCourse[_studentAddress]).length == 0) {\n            studentToCourse[_studentAddress] = _courseCode;\n        }\n        Grade[] storage studentGrades = grades[_studentAddress];\n        for (uint256 i = 0; i < studentGrades.length; i++) {\n            require(\n                !(keccak256(\n                    abi.encodePacked(studentGrades[i].disciplineCode)\n                ) ==\n                    keccak256(abi.encodePacked(_gradeInfo.disciplineCode)) &&\n                    studentGrades[i].semester == _gradeInfo.semester &&\n                    studentGrades[i].year == _gradeInfo.year),\n                \"Grade already recorded for this discipline, semester and year!\"\n            );\n        }\n        grades[_studentAddress].push(\n            Grade(\n                _gradeInfo.disciplineCode,\n                _gradeInfo.semester,\n                _gradeInfo.year,\n                _gradeInfo.grade,\n                _gradeInfo.attendance,\n                _gradeInfo.status\n            )\n        );\n\n        emit GradeAdded(\n            _studentAddress,\n            _gradeInfo.disciplineCode,\n            _gradeInfo.year,\n            _gradeInfo.semester\n        );\n    }\n\n    function addBatchGrades(\n        address _institutionAddress,\n        BatchGradePayload[] calldata _gradesInfo\n    ) public institutionExists(_institutionAddress) onlyInstitution {\n        require(\n            msg.sender == _institutionAddress,\n            \"Only the specified institution can add grades in batch.\"\n        );\n\n        uint256 len = _gradesInfo.length;\n\n        require(len > 0, \"No grades to register in batch.\");\n\n        for (uint256 i = 0; i < len; i++) {\n            BatchGradePayload memory info = _gradesInfo[i];\n\n            address currentStudentAddress = info.studentAddress;\n            string memory currentCourseCode = info.courseCode;\n            string memory currentDisciplineCode = info.disciplineCode;\n            uint8 currentSemester = info.semester;\n            uint16 currentYear = info.year;\n\n            require(\n                students[currentStudentAddress].studentAddress != address(0),\n                \"Student not registered!\"\n            );\n            bytes32 courseHash = keccak256(abi.encodePacked(currentCourseCode));\n            bytes32 disciplineHash = keccak256(\n                abi.encodePacked(currentDisciplineCode)\n            );\n\n            require(\n                disciplineExistsInCourse[courseHash][disciplineHash],\n                \"Discipline not found in this course!\"\n            );\n            if (bytes(studentToCourse[currentStudentAddress]).length == 0) {\n                studentToCourse[currentStudentAddress] = currentCourseCode;\n            }\n\n            Grade[] storage studentGrades = grades[currentStudentAddress];\n            for (uint256 j = 0; j < studentGrades.length; j++) {\n                require(\n                    !(keccak256(\n                        abi.encodePacked(studentGrades[j].disciplineCode)\n                    ) ==\n                        keccak256(abi.encodePacked(currentDisciplineCode)) &&\n                        studentGrades[j].semester == currentSemester &&\n                        studentGrades[j].year == currentYear),\n                    \"Duplicate grade found for student, discipline, semester and year!\"\n                );\n            }\n            grades[currentStudentAddress].push(\n                Grade(\n                    currentDisciplineCode,\n                    currentSemester,\n                    currentYear,\n                    info.grade,\n                    info.attendance,\n                    info.status\n                )\n            );\n            emit GradeAdded(\n                currentStudentAddress,\n                currentDisciplineCode,\n                currentYear,\n                currentSemester\n            );\n        }\n    }\n\n    function retrieveRecipientEncrpytKey(\n        address _allowedAddress,\n        address _studentAddress\n    )\n        public\n        view\n        studentExists(_studentAddress)\n        returns (string memory)\n    {\n        require(\n            bytes(recipientEncryptKey[_studentAddress][_allowedAddress])\n                .length != 0,\n            \"Recipient's Key was not shared yet!\"\n        );\n        return recipientEncryptKey[_studentAddress][_allowedAddress];\n    }\n\n    function addEncryptedInfoWithRecipientKey(\n        address _allowedAddress,\n        address _studentAddress,\n        string calldata _encryptedData\n    ) public studentExists(_studentAddress) onlyStudent(_studentAddress) {\n        studentInfoRecipient[_studentAddress][_allowedAddress] = _encryptedData;\n    }\n\n    function getEncryptedInfoWithRecipientKey(\n        address _allowedAddress,\n        address _studentAddress\n    ) public view studentExists(_studentAddress) returns (string memory) {\n        return studentInfoRecipient[_studentAddress][_allowedAddress];\n    }\n\n    function addStudentInformation(\n        string calldata _selfEncryptedInformation,\n        string calldata _encryptedInformation,\n        string calldata _publicKey,\n        string calldata _publicHash\n    ) public onlyStudent(msg.sender) studentExists(msg.sender) {\n        students[msg.sender].selfEncryptedInformation = _selfEncryptedInformation;\n        students[msg.sender]\n            .institutionEncryptedInformation = _encryptedInformation;\n        students[msg.sender].publicKey = _publicKey;\n        students[msg.sender].publicHash = _publicHash;\n        emit StudentInformationAdded(msg.sender);\n    }\n\n    // function confirmStudentInformation(\n    //     address _studentAddress,\n    //     address _institutionAddress,\n    //     string calldata _encryptedInformation\n    // )\n    //     public\n    //     onlyInstitution\n    //     studentExists(_studentAddress)\n    //     studentIsInstitution(_studentAddress, _institutionAddress)\n    // {\n    //     require(\n    //         msg.sender == _institutionAddress,\n    //         \"Only the specified institution can confirm student information.\"\n    //     );\n    //     students[_studentAddress]\n    //         .selfEncryptedInformation = _encryptedInformation;\n    // }\n\n    function getPermission() public view returns (string memory) {\n        if (msg.sender == contractOwner) {\n            return \"owner\";\n        }\n        if (students[msg.sender].studentAddress != address(0)) {\n            return \"student\";\n        }\n        if (isInstitution[msg.sender]) {\n            return \"institution\";\n        }\n        return \"viewer\";\n    }\n\n    function getStudentInstitutionData(\n        address _studentAddress\n    )\n        public\n        view\n        returns (Institution memory institution, Course memory course)\n    {\n        string memory courseCode = studentToCourse[_studentAddress];\n        require(\n            bytes(courseCode).length > 0,\n            \"Student not enrolled in any course or no course associated!\"\n        );\n\n        address institutionAddress = studentToInstitution[_studentAddress];\n        require(\n            institutionAddress != address(0),\n            \"Student not associated with any institution!\"\n        );\n        Course[] memory institutionCourses = courses[institutionAddress];\n        for (uint i = 0; i < institutionCourses.length; i++) {\n            if (\n                keccak256(abi.encodePacked(institutionCourses[i].code)) ==\n                keccak256(abi.encodePacked(courseCode))\n            ) {\n                return (\n                    institutions[institutionAddress],\n                    institutionCourses[i]\n                );\n            }\n        }\n        revert(\"Course not found for student's associated institution!\");\n    }\n\n    function getStudentTranscript(\n        address _studentAddress\n    ) public view returns (Grade[] memory, Discipline[] memory) {\n        require(\n            bytes(studentToCourse[_studentAddress]).length > 0,\n            \"Student not enrolled in any course or no course associated!\"\n        );\n        Grade[] memory studentGrades = grades[_studentAddress];\n        Discipline[] memory disciplineDetails = new Discipline[](\n            studentGrades.length\n        );\n        bytes32 courseHash = keccak256(\n            abi.encodePacked(studentToCourse[_studentAddress])\n        );\n\n        Discipline[] memory courseDisciplines = disciplinesByCourse[courseHash];\n        require(\n            courseDisciplines.length > 0,\n            \"No disciplines found for student's course!\"\n        );\n        for (uint256 i = 0; i < studentGrades.length; i++) {\n            bytes32 gradeDisciplineHash = keccak256(\n                abi.encodePacked(studentGrades[i].disciplineCode)\n            );\n            bool foundDiscipline = false;\n            for (uint256 j = 0; j < courseDisciplines.length; j++) {\n                if (\n                    keccak256(abi.encodePacked(courseDisciplines[j].code)) ==\n                    gradeDisciplineHash\n                ) {\n                    disciplineDetails[i] = courseDisciplines[j];\n                    foundDiscipline = true;\n                    break;\n                }\n            }\n            require(\n                foundDiscipline,\n                \"Discipline for grade not found in course disciplines!\"\n            );\n        }\n        return (studentGrades, disciplineDetails);\n    }\n\n    function getStudentGrades(\n        address _studentAddress\n    ) public view returns (Grade[] memory) {\n        return grades[_studentAddress];\n    }\n\n    function requestAccess(\n        address _studentAddress,\n        string calldata _encryptKey\n    ) public studentExists(_studentAddress) {\n        recipientEncryptKey[_studentAddress][msg.sender] = _encryptKey;\n    }\n}\n"
      }
    }
  }
}
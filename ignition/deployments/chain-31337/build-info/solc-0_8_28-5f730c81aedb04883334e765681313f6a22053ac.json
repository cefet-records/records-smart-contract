{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-5f730c81aedb04883334e765681313f6a22053ac",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/AcademicRecordStorage.sol": "project/contracts/AcademicRecordStorage.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/AcademicRecordStorage.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\ncontract AcademicRecordStorage {\r\n    event InstitutionAdded(address indexed institutionAddress);\r\n    event InstitutionInformationAdded(\r\n        address indexed institutionAddress,\r\n        string name,\r\n        string document\r\n    );\r\n    event CourseAdded(address indexed institutionAddress, string courseCode);\r\n    event DisciplineAdded(string courseCode, string disciplineCode);\r\n    event StudentAdded(address indexed studentAddress);\r\n    event GradeAdded(\r\n        address indexed studentAddress,\r\n        string disciplineCode,\r\n        uint16 year,\r\n        uint8 semester\r\n    );\r\n    event AllowedAddressAdded(\r\n        address indexed studentAddress,\r\n        address allowedAddress\r\n    );\r\n    event StudentInformationAdded(address indexed studentAddress);\r\n\r\n    address public immutable contractOwner;\r\n    address[] private institutionAddressList;\r\n    mapping(address => bool) public isInstitution;\r\n\r\n    struct Institution {\r\n        address institutionAddress;\r\n        string name;\r\n        string document;\r\n        string publicKey;\r\n    }\r\n\r\n    struct Course {\r\n        string code;\r\n        string name;\r\n        string courseType;\r\n        int numberOfSemesters;\r\n    }\r\n\r\n    struct Discipline {\r\n        string code;\r\n        string name;\r\n        string syllabus;\r\n        int workload;\r\n        int creditCount;\r\n    }\r\n\r\n    struct Student {\r\n        address studentAddress;\r\n        string selfEncryptedInformation;\r\n        string institutionEncryptedInformation;\r\n        string publicKey;\r\n        string publicHash;\r\n    }\r\n\r\n    struct Grade {\r\n        string disciplineCode;\r\n        uint8 semester;\r\n        uint16 year;\r\n        uint8 grade;\r\n        uint8 attendance;\r\n        bool status;\r\n    }\r\n\r\n    struct BatchGradePayload {\r\n        address studentAddress;\r\n        string courseCode;\r\n        string disciplineCode;\r\n        uint8 semester;\r\n        uint16 year;\r\n        uint8 grade;\r\n        uint8 attendance;\r\n        bool status;\r\n    }\r\n\r\n    mapping(address => Institution) private institutions;\r\n    mapping(address => Course[]) private courses;\r\n    mapping(address => Student) private students;\r\n    mapping(address => Grade[]) private grades;\r\n    mapping(bytes32 => mapping(bytes32 => bool))\r\n        private disciplineExistsInCourse;\r\n    mapping(bytes32 => Discipline[]) private disciplinesByCourse;\r\n    mapping(address => mapping(bytes32 => bool)) private enrollments;\r\n    mapping(address => mapping(address => string)) private recipientEncryptKey;\r\n    mapping(address => mapping(address => string)) private studentInfoRecipient;\r\n    mapping(address => address) private studentToInstitution;\r\n    mapping(address => string) private studentToCourse;\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == contractOwner,\r\n            \"Only the contract owner can perform this action!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyInstitution() {\r\n        require(\r\n            isInstitution[msg.sender],\r\n            \"Caller is not a registered institution!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyStudent(address studentAddress) {\r\n        require(\r\n            msg.sender == studentAddress,\r\n            \"Only the student can perform this action!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier institutionExists(address institutionAddress) {\r\n        require(\r\n            institutions[institutionAddress].institutionAddress != address(0),\r\n            \"Institution is not registered!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier studentExists(address studentAddress) {\r\n        require(\r\n            students[studentAddress].studentAddress != address(0),\r\n            \"Student is not registered!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier studentIsInstitution(\r\n        address studentAddress,\r\n        address institutionAddress\r\n    ) {\r\n        require(\r\n            studentToInstitution[studentAddress] == institutionAddress,\r\n            \"Student is not in this Institution!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier courseExists(\r\n        address _institutionAddress,\r\n        string memory _courseCode\r\n    ) {\r\n        bool exists = false;\r\n        Course[] storage institutionCourses = courses[_institutionAddress];\r\n        for (uint256 i = 0; i < institutionCourses.length; i++) {\r\n            if (\r\n                keccak256(abi.encodePacked(institutionCourses[i].code)) ==\r\n                keccak256(abi.encodePacked(_courseCode))\r\n            ) {\r\n                exists = true;\r\n                break;\r\n            }\r\n        }\r\n        require(exists, \"Course not found!\");\r\n        _;\r\n    }\r\n\r\n    modifier disciplineExists(bytes32 _courseHash, bytes32 _disciplineHash) {\r\n        require(\r\n            disciplineExistsInCourse[_courseHash][_disciplineHash],\r\n            \"Discipline not found in this course!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return contractOwner;\r\n    }\r\n\r\n    function addInstitution(address _institutionAddress) public onlyOwner {\r\n        require(\r\n            institutions[_institutionAddress].institutionAddress == address(0),\r\n            \"Institution already registered!\"\r\n        );\r\n        institutions[_institutionAddress] = Institution(\r\n            _institutionAddress,\r\n            \"\",\r\n            \"\",\r\n            \"\"\r\n        );\r\n        institutionAddressList.push(_institutionAddress);\r\n        isInstitution[_institutionAddress] = true;\r\n        emit InstitutionAdded(_institutionAddress);\r\n    }\r\n\r\n    function addInstitutionInformation(\r\n        string calldata _name,\r\n        string calldata _document\r\n    ) public onlyInstitution {\r\n        require(\r\n            bytes(_name).length > 0,\r\n            \"Institution document cannot be empty\"\r\n        );\r\n        require(\r\n            bytes(_document).length > 0,\r\n            \"Institution document cannot be empty\"\r\n        );\r\n        Institution storage inst = institutions[msg.sender];\r\n        require(\r\n            inst.institutionAddress != address(0),\r\n            \"Institution profile not found.\"\r\n        );\r\n        inst.name = _name;\r\n        inst.document = _document;\r\n        emit InstitutionInformationAdded(msg.sender, _name, _document);\r\n    }\r\n\r\n    function addInstitutionPublicKey(\r\n        address _institutionAddress,\r\n        string calldata _publicKey\r\n    ) public onlyInstitution {\r\n        require(\r\n            msg.sender == _institutionAddress,\r\n            \"Only the institution itself can add its public key!\"\r\n        );\r\n        institutions[_institutionAddress].publicKey = _publicKey;\r\n    }\r\n\r\n    function getInstitution(\r\n        address _institutionAddress\r\n    ) public view returns (Institution memory) {\r\n        return institutions[_institutionAddress];\r\n    }\r\n\r\n    function getInstitutionList() public view returns (address[] memory) {\r\n        return institutionAddressList;\r\n    }\r\n\r\n    function addCourse(\r\n        address _institutionAddress,\r\n        string calldata _code,\r\n        string calldata _name,\r\n        string calldata _courseType,\r\n        int _numberOfSemesters\r\n    ) public institutionExists(_institutionAddress) onlyInstitution {\r\n        require(\r\n            msg.sender == _institutionAddress,\r\n            \"Only the specified institution can add courses to itself.\"\r\n        );\r\n        Course[] storage institutionCourses = courses[_institutionAddress];\r\n        for (uint256 i = 0; i < institutionCourses.length; i++) {\r\n            require(\r\n                keccak256(abi.encodePacked(institutionCourses[i].code)) !=\r\n                    keccak256(abi.encodePacked(_code)),\r\n                \"Course already registered!\"\r\n            );\r\n        }\r\n        courses[_institutionAddress].push(\r\n            Course(_code, _name, _courseType, _numberOfSemesters)\r\n        );\r\n        emit CourseAdded(_institutionAddress, _code);\r\n    }\r\n\r\n    function addDisciplineToCourse(\r\n        address institutionAddress,\r\n        string calldata courseCode,\r\n        string calldata disciplineCode,\r\n        string calldata name,\r\n        string calldata syllabus,\r\n        int workload,\r\n        int creditCount\r\n    ) public courseExists(institutionAddress, courseCode) onlyInstitution {\r\n        _addDisciplineToCourse(\r\n            courseCode,\r\n            disciplineCode,\r\n            name,\r\n            syllabus,\r\n            workload,\r\n            creditCount\r\n        );\r\n    }\r\n\r\n    function _addDisciplineToCourse(\r\n        string calldata courseCode,\r\n        string calldata disciplineCode,\r\n        string calldata name,\r\n        string calldata syllabus,\r\n        int workload,\r\n        int creditCount\r\n    ) internal {\r\n        bytes32 courseHash = keccak256(abi.encodePacked(courseCode));\r\n        bytes32 disciplineHash = keccak256(abi.encodePacked(disciplineCode));\r\n\r\n        require(\r\n            !disciplineExistsInCourse[courseHash][disciplineHash],\r\n            \"Discipline already registered in this course!\"\r\n        );\r\n\r\n        disciplinesByCourse[courseHash].push(\r\n            Discipline(disciplineCode, name, syllabus, workload, creditCount)\r\n        );\r\n        disciplineExistsInCourse[courseHash][disciplineHash] = true;\r\n\r\n        emit DisciplineAdded(courseCode, disciplineCode);\r\n    }\r\n\r\n    function addStudent(\r\n        address _institutionAddress,\r\n        address _studentAddress\r\n    ) public institutionExists(_institutionAddress) onlyInstitution {\r\n        require(\r\n            msg.sender == _institutionAddress,\r\n            \"Only the specified institution can add students to itself.\"\r\n        );\r\n        require(\r\n            students[_studentAddress].studentAddress == address(0),\r\n            \"Student already registered!\"\r\n        );\r\n        students[_studentAddress] = Student(_studentAddress, \"\", \"\", \"\", \"\");\r\n        studentToInstitution[_studentAddress] = _institutionAddress;\r\n        emit StudentAdded(_studentAddress);\r\n    }\r\n\r\n    function getStudent(\r\n        address _studentAddress\r\n    ) public view returns (Student memory) {\r\n        return students[_studentAddress];\r\n    }\r\n\r\n    function addGrade(\r\n        address _institutionAddress,\r\n        address _studentAddress,\r\n        string calldata _courseCode,\r\n        Grade calldata _gradeInfo\r\n    )\r\n        public\r\n        institutionExists(_institutionAddress)\r\n        onlyInstitution\r\n        studentExists(_studentAddress)\r\n    {\r\n        require(\r\n            msg.sender == _institutionAddress,\r\n            \"Only the specified institution can add grades.\"\r\n        );\r\n        bytes32 courseHash = keccak256(abi.encodePacked(_courseCode));\r\n        bytes32 disciplineHash = keccak256(\r\n            abi.encodePacked(_gradeInfo.disciplineCode)\r\n        );\r\n\r\n        require(\r\n            disciplineExistsInCourse[courseHash][disciplineHash],\r\n            \"Discipline not found in this course!\"\r\n        );\r\n        if (bytes(studentToCourse[_studentAddress]).length == 0) {\r\n            studentToCourse[_studentAddress] = _courseCode;\r\n        }\r\n        Grade[] storage studentGrades = grades[_studentAddress];\r\n        for (uint256 i = 0; i < studentGrades.length; i++) {\r\n            require(\r\n                !(keccak256(\r\n                    abi.encodePacked(studentGrades[i].disciplineCode)\r\n                ) ==\r\n                    keccak256(abi.encodePacked(_gradeInfo.disciplineCode)) &&\r\n                    studentGrades[i].semester == _gradeInfo.semester &&\r\n                    studentGrades[i].year == _gradeInfo.year),\r\n                \"Grade already recorded for this discipline, semester and year!\"\r\n            );\r\n        }\r\n        grades[_studentAddress].push(\r\n            Grade(\r\n                _gradeInfo.disciplineCode,\r\n                _gradeInfo.semester,\r\n                _gradeInfo.year,\r\n                _gradeInfo.grade,\r\n                _gradeInfo.attendance,\r\n                _gradeInfo.status\r\n            )\r\n        );\r\n\r\n        emit GradeAdded(\r\n            _studentAddress,\r\n            _gradeInfo.disciplineCode,\r\n            _gradeInfo.year,\r\n            _gradeInfo.semester\r\n        );\r\n    }\r\n\r\n    function addBatchGrades(\r\n        address _institutionAddress,\r\n        BatchGradePayload[] calldata _gradesInfo\r\n    ) public institutionExists(_institutionAddress) onlyInstitution {\r\n        require(\r\n            msg.sender == _institutionAddress,\r\n            \"Only the specified institution can add grades in batch.\"\r\n        );\r\n\r\n        uint256 len = _gradesInfo.length;\r\n\r\n        require(len > 0, \"No grades to register in batch.\");\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            BatchGradePayload memory info = _gradesInfo[i];\r\n\r\n            address currentStudentAddress = info.studentAddress;\r\n            string memory currentCourseCode = info.courseCode;\r\n            string memory currentDisciplineCode = info.disciplineCode;\r\n            uint8 currentSemester = info.semester;\r\n            uint16 currentYear = info.year;\r\n\r\n            require(\r\n                students[currentStudentAddress].studentAddress != address(0),\r\n                \"Student not registered!\"\r\n            );\r\n            bytes32 courseHash = keccak256(abi.encodePacked(currentCourseCode));\r\n            bytes32 disciplineHash = keccak256(\r\n                abi.encodePacked(currentDisciplineCode)\r\n            );\r\n\r\n            require(\r\n                disciplineExistsInCourse[courseHash][disciplineHash],\r\n                \"Discipline not found in this course!\"\r\n            );\r\n            if (bytes(studentToCourse[currentStudentAddress]).length == 0) {\r\n                studentToCourse[currentStudentAddress] = currentCourseCode;\r\n            }\r\n\r\n            Grade[] storage studentGrades = grades[currentStudentAddress];\r\n            for (uint256 j = 0; j < studentGrades.length; j++) {\r\n                require(\r\n                    !(keccak256(\r\n                        abi.encodePacked(studentGrades[j].disciplineCode)\r\n                    ) ==\r\n                        keccak256(abi.encodePacked(currentDisciplineCode)) &&\r\n                        studentGrades[j].semester == currentSemester &&\r\n                        studentGrades[j].year == currentYear),\r\n                    \"Duplicate grade found for student, discipline, semester and year!\"\r\n                );\r\n            }\r\n            grades[currentStudentAddress].push(\r\n                Grade(\r\n                    currentDisciplineCode,\r\n                    currentSemester,\r\n                    currentYear,\r\n                    info.grade,\r\n                    info.attendance,\r\n                    info.status\r\n                )\r\n            );\r\n            emit GradeAdded(\r\n                currentStudentAddress,\r\n                currentDisciplineCode,\r\n                currentYear,\r\n                currentSemester\r\n            );\r\n        }\r\n    }\r\n\r\n    function retrieveRecipientEncrpytKey(\r\n        address _allowedAddress,\r\n        address _studentAddress\r\n    ) public view studentExists(_studentAddress) returns (string memory) {\r\n        require(\r\n            bytes(recipientEncryptKey[_studentAddress][_allowedAddress])\r\n                .length != 0,\r\n            \"Recipient's Key was not shared yet!\"\r\n        );\r\n        return recipientEncryptKey[_studentAddress][_allowedAddress];\r\n    }\r\n\r\n    function addEncryptedInfoWithRecipientKey(\r\n        address _allowedAddress,\r\n        address _studentAddress,\r\n        string calldata _encryptedData\r\n    ) public studentExists(_studentAddress) onlyStudent(_studentAddress) {\r\n        studentInfoRecipient[_studentAddress][_allowedAddress] = _encryptedData;\r\n    }\r\n\r\n    function getEncryptedInfoWithRecipientKey(\r\n        address _allowedAddress,\r\n        address _studentAddress\r\n    ) public view studentExists(_studentAddress) returns (string memory) {\r\n        return studentInfoRecipient[_studentAddress][_allowedAddress];\r\n    }\r\n\r\n    function addStudentInformation(\r\n        string calldata _selfEncryptedInformation,\r\n        string calldata _encryptedInformation,\r\n        string calldata _publicKey,\r\n        string calldata _publicHash\r\n    ) public onlyStudent(msg.sender) studentExists(msg.sender) {\r\n        students[msg.sender]\r\n            .selfEncryptedInformation = _selfEncryptedInformation;\r\n        students[msg.sender]\r\n            .institutionEncryptedInformation = _encryptedInformation;\r\n        students[msg.sender].publicKey = _publicKey;\r\n        students[msg.sender].publicHash = _publicHash;\r\n        emit StudentInformationAdded(msg.sender);\r\n    }\r\n\r\n    // function confirmStudentInformation(\r\n    //     address _studentAddress,\r\n    //     address _institutionAddress,\r\n    //     string calldata _encryptedInformation\r\n    // )\r\n    //     public\r\n    //     onlyInstitution\r\n    //     studentExists(_studentAddress)\r\n    //     studentIsInstitution(_studentAddress, _institutionAddress)\r\n    // {\r\n    //     require(\r\n    //         msg.sender == _institutionAddress,\r\n    //         \"Only the specified institution can confirm student information.\"\r\n    //     );\r\n    //     students[_studentAddress]\r\n    //         .selfEncryptedInformation = _encryptedInformation;\r\n    // }\r\n\r\n    function getPermission() public view returns (string memory) {\r\n        if (msg.sender == contractOwner) {\r\n            return \"owner\";\r\n        }\r\n        if (students[msg.sender].studentAddress != address(0)) {\r\n            return \"student\";\r\n        }\r\n        if (isInstitution[msg.sender]) {\r\n            return \"institution\";\r\n        }\r\n        return \"viewer\";\r\n    }\r\n\r\n    function getStudentInstitutionData(\r\n        address _studentAddress\r\n    )\r\n        public\r\n        view\r\n        returns (Institution memory institution, Course memory course)\r\n    {\r\n        string memory courseCode = studentToCourse[_studentAddress];\r\n        require(\r\n            bytes(courseCode).length > 0,\r\n            \"Student not enrolled in any course or no course associated!\"\r\n        );\r\n\r\n        address institutionAddress = studentToInstitution[_studentAddress];\r\n        require(\r\n            institutionAddress != address(0),\r\n            \"Student not associated with any institution!\"\r\n        );\r\n        Course[] memory institutionCourses = courses[institutionAddress];\r\n        for (uint i = 0; i < institutionCourses.length; i++) {\r\n            if (\r\n                keccak256(abi.encodePacked(institutionCourses[i].code)) ==\r\n                keccak256(abi.encodePacked(courseCode))\r\n            ) {\r\n                return (\r\n                    institutions[institutionAddress],\r\n                    institutionCourses[i]\r\n                );\r\n            }\r\n        }\r\n        revert(\"Course not found for student's associated institution!\");\r\n    }\r\n\r\n    function getStudentTranscript(\r\n        address _studentAddress\r\n    ) public view returns (Grade[] memory, Discipline[] memory) {\r\n        require(\r\n            bytes(studentToCourse[_studentAddress]).length > 0,\r\n            \"Student not enrolled in any course or no course associated!\"\r\n        );\r\n        Grade[] memory studentGrades = grades[_studentAddress];\r\n        Discipline[] memory disciplineDetails = new Discipline[](\r\n            studentGrades.length\r\n        );\r\n        bytes32 courseHash = keccak256(\r\n            abi.encodePacked(studentToCourse[_studentAddress])\r\n        );\r\n\r\n        Discipline[] memory courseDisciplines = disciplinesByCourse[courseHash];\r\n        require(\r\n            courseDisciplines.length > 0,\r\n            \"No disciplines found for student's course!\"\r\n        );\r\n        for (uint256 i = 0; i < studentGrades.length; i++) {\r\n            bytes32 gradeDisciplineHash = keccak256(\r\n                abi.encodePacked(studentGrades[i].disciplineCode)\r\n            );\r\n            bool foundDiscipline = false;\r\n            for (uint256 j = 0; j < courseDisciplines.length; j++) {\r\n                if (\r\n                    keccak256(abi.encodePacked(courseDisciplines[j].code)) ==\r\n                    gradeDisciplineHash\r\n                ) {\r\n                    disciplineDetails[i] = courseDisciplines[j];\r\n                    foundDiscipline = true;\r\n                    break;\r\n                }\r\n            }\r\n            require(\r\n                foundDiscipline,\r\n                \"Discipline for grade not found in course disciplines!\"\r\n            );\r\n        }\r\n        return (studentGrades, disciplineDetails);\r\n    }\r\n\r\n    function getStudentGrades(\r\n        address _studentAddress\r\n    ) public view returns (Grade[] memory) {\r\n        return grades[_studentAddress];\r\n    }\r\n\r\n    function requestAccess(\r\n        address _studentAddress,\r\n        string calldata _encryptKey\r\n    ) public studentExists(_studentAddress) {\r\n        recipientEncryptKey[_studentAddress][msg.sender] = _encryptKey;\r\n    }\r\n}\r\n"
      }
    }
  }
}